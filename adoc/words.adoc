= :guide Presenting Neo4j by Chris Banks
:neo4j-version: 5.21
:author: Chris Banks

== Introduction to Neo4j (3 minutes)

Neo4j is a powerful graph database management system designed to handle highly interconnected data. Unlike traditional relational databases, Neo4j stores data in a graph structure consisting of nodes, relationships, and properties.

- *TODO*: Add additional data points

Want to know more?
 
* pass:a[<a play-topic='intro'>Browser Guide</a>]
* pass:a[<a play-topic='concepts'>Neo4j Concepts</a>]
* pass:a[<a play-topic='fundamentals'>About Cypher</a>]
* pass:a[<a play-topic='cypher'>Intro to Cypher</a>]
* pass:a[<a help-topic='help'>Help Me</a>]

Developer Training

- *TODO*: Link Graph academy opens in a new window
- *TODO*: Link Neo4j Sandbox opens in a new window

== Advantages over Relational SQL Databases (5 minutes)

Neo4j offers several advantages over relational SQL databases:

- *Schema Flexibility*: Neo4j is schema-free, allowing for dynamic and agile data modeling compared to rigid schemas in SQL databases.
- *Performance*: Graph traversal in Neo4j is efficient for complex queries involving interconnected data, eliminating the need for expensive join operations.
- *Use Cases*: Neo4j excels in scenarios such as social networks, recommendation engines, fraud detection, and pathfinding problems.

-*TODO*: ADD links to relevant documentation published by neo4j 

== Demo: Graph Algorithms and Shortest Path (5 minutes)

In this demo, we'll explore how Neo4j handles graph algorithms with a practical example similar to the word game "Tangle":

*Scenario*: Given two 5-letter English words, find the shortest path between them where each step changes one letter to form a valid English word.

*Implementation*:

- **Step 1**: Load a dataset of English words into Neo4j as nodes.
- **Step 2**: Create relationships between nodes (words) if they differ by exactly one character.
- **Step 3**: Execute a shortest path algorithm query to find the shortest transformation path between two input words.

== Load the dataset of English words

The below cypher loads data from the import folder of neo4j 

[source,cypher]
LOAD CSV FROM 'file:///words.csv' AS row
WITH row[0] AS word 
WHERE size(word) >= 3 AND size(word) <= 6
CREATE (:Word {value: word, length: size(word)})

If the above file was not found you can load the dataset via a url

[source, cypher]
LOAD CSV FROM 'https://raw.githubusercontent.com/dwyl/english-words/master/words_alpha.txt' AS row
WITH row[0] AS word
WHERE size(word) >= 3 AND size(word) <= 6
CREATE (:Word {value: word, length: size(word)})

Expand the knowledge graph with character positions for each letter within the word

[source,cypher]
MATCH (word:Word)
WITH word
Foreach (i in range(1, word.length) | MERGE (l:Letter {value: substring(word.value,i-1,1), position: i}) MERGE (word)-[:CONTAINS]->(l))

- *TODO*: add links to each keyword found in the cypher above i.e. :help Foreach

== Create relationships between nodes (words) 

create the linked relationship using https://neo4j.com/docs/graph-data-science/current/algorithms/node-similarity/[*Overlap Similarity*^]

//image::http://localhost:8081/img/overlap_nodesim.svg[Static,300]

Project the data into a named graph
[source,cypher]
CALL gds.graph.project(
    'myGraph',
    ['Word', 'Letter'],
    {
        CONTAINS: {
        }
    }
);

Determine the similarity by calculating the overlap coefficient 
based on the letters in the words and the letters position within the word

[source,cypher]
UNWIND range(3,6) AS wordlength
CALL gds.nodeSimilarity.write('myGraph', {
    writeRelationshipType: 'OVERLAP',
    writeProperty: 'score',
    topK: 1000, //each node can have at most 1000 similar nodes
    degreeCutoff: wordlength, //only include words with the number of letters >=  wordlength
    upperDegreeCutoff: wordlength, //only include words with the number of letters <= wordlength 
    similarityCutoff: (wordlength -1 * 1.0) / (wordlength * 1.0) // only 
})
YIELD nodesCompared, relationshipsWritten
RETURN *

- *TODO*: add links for each GDS statement explaining what is happening 

== Execute a shortest path algorithm

-*TODO*: add shortest path example use parameterized query to demonstrate 